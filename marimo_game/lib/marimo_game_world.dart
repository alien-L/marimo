import 'dart:math';
import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flame/input.dart';
import 'package:flame_bloc/flame_bloc.dart';
import 'package:flutter/cupertino.dart';
import 'app_manage/local_repository.dart';
import 'bloc/marimo_bloc/marimo_bloc.dart';
import 'components/world.dart';
import 'components/world_collidable.dart';
import 'helpers/direction.dart';
import 'components/coin_component.dart';
import 'components/marimo_component.dart';
import 'package:flame/experimental.dart' as ex;


class MarimoWorldGame extends FlameGame
    with PanDetector, HasCollisionDetection, HasKeyboardHandlerComponents {
  late MarimoComponent marimoComponent;
  int coinsCollected = 0;
  final MarimoBloc marimoBloc;
  late Timer bulletCreator;
  final List<CoinComponent> _coinList = List<CoinComponent>.empty(growable: true);
  final World _world = World();
  LocalRepository localRepository = LocalRepository();

  MarimoWorldGame({
    required this.marimoBloc,
  });

  void onJoypadDirectionChanged(Direction direction) {
    print("ü¶Ñü¶Ñ ${marimoComponent.position}");
    marimoComponent.direction = direction;
  }

  @override
  Future<void> onLoad() async {
    final marimoLevel = await localRepository.getValue(key: "MarimoLevel");
    await add(_world);
    await add(
      FlameMultiBlocProvider(
        providers: [
          FlameBlocProvider<MarimoBloc, MarimoState>.value(
            value: marimoBloc,
          ),
        ],
        children: [
          marimoComponent = MarimoComponent(name: marimoLevel!),
          MarimoController(),
        ],
      ),
    );

   // ÏΩîÏù∏ Ï°∞Í±¥ ÎÑ£Ïñ¥Ï£ºÍ∏∞
    for (var i = 0; i < 10; i++) {
      final tempCoin = CoinComponent(size);
      _coinList.add(tempCoin);
      add(tempCoin);
    }
    marimoComponent.position = _world.size / 2;

    camera.followComponent(marimoComponent,
        worldBounds: Rect.fromLTRB(0, 0, _world.size.x, _world.size.y));

  }

  final Map<int, ExpandingCircle> _circles = {};

  WorldCollidable createWorldCollidable(Rect rect) {
    final collidable = WorldCollidable();
    collidable.position = Vector2(rect.left, rect.top);
    collidable.width = rect.width;
    collidable.height = rect.height;

    return collidable;
  }

  @override
  void onTapDown(ex.TapDownEvent event) {
    final circle = ExpandingCircle(event.localPosition);
    _circles[event.pointerId] = circle;
    add(circle);
  }

  @override
  void onLongTapDown(ex.TapDownEvent event) {
    _circles[event.pointerId]!.accent();
  }

  @override
  void onTapUp(ex.TapUpEvent event) {
    _circles.remove(event.pointerId)!.release();
  }

  @override
  void onTapCancel(ex.TapCancelEvent event) {
    _circles.remove(event.pointerId)!.cancel();
  }
}

class ExpandingCircle extends Component {
  ExpandingCircle(this._center)
      : _baseColor =
            HSLColor.fromAHSL(1, random.nextDouble() * 360, 1, 0.8).toColor();

  final Color _baseColor;
  final Vector2 _center;
  double _outerRadius = 0;
  double _innerRadius = 0;
  bool _released = false;
  bool _cancelled = false;
  late final _paint = Paint()
    ..style = PaintingStyle.stroke
    ..color = _baseColor;

  /// "Accent" is thin white circle generated by `onLongTapDown`. We use
  /// negative radius to indicate that the circle should not be drawn yet.
  double _accentRadius = -1e10;
  late final _accentPaint = Paint()
    ..style = PaintingStyle.stroke
    ..strokeWidth = 0
    ..color = const Color(0xFFFFFFFF);

  /// At this radius the circle will disappear.
  static const maxRadius = 175;
  static final random = Random();

  double get radius => (_innerRadius + _outerRadius) / 2;

  void release() => _released = true;

  void cancel() => _cancelled = true;

  void accent() => _accentRadius = 0;

  @override
  void render(Canvas canvas) {
    canvas.drawCircle(_center.toOffset(), radius, _paint);
    if (_accentRadius >= 0) {
      canvas.drawCircle(_center.toOffset(), _accentRadius, _accentPaint);
    }
  }

  @override
  void update(double dt) {
    if (_cancelled) {
      _innerRadius += dt * 100; // implosion
    } else {
      _outerRadius += dt * 20;
      _innerRadius += dt * (_released ? 20 : 6);
      _accentRadius += dt * 20;
    }
    if (radius >= maxRadius || _innerRadius > _outerRadius) {
      removeFromParent();
    } else {
      final opacity = 1 - radius / maxRadius;
      _paint.color = _baseColor.withOpacity(opacity);
      _paint.strokeWidth = _outerRadius - _innerRadius;
    }
  }
}
